import sys
from typing import Tuple, List
from dataclasses import dataclass

try:
    from .naming import member, namespace
except ImportError:
    from naming import member, namespace


def generate(data, name: str, file: str, abs_path: str) -> Tuple[str, str]:
    out = write_field(name, data, [])
    hpp_content = f"""#pragma once
// This file is auto-generated by yamlgenpp
#include <string>
#include <vector>
#include <yaml-cpp/yaml.h>

namespace yamlgenpp {{

{out.hpp_prepend}
}}
extern yamlgenpp::{namespace(name)}::dict {member(name)};
"""
    cpp_content = f"""
// This file is auto-generated by yamlgenpp
#include "{file}.hpp"
#include <filesystem>

{out.cpp_prepend}
yamlgenpp::{namespace(name)}::dict {member(name)}(YAML::LoadFile("{abs_path}"));
"""
    return hpp_content, cpp_content


@dataclass
class FieldOutput:
    hpp_inline: str = ""
    hpp_prepend: str = ""
    cpp_inline: str = ""
    cpp_body: str = ""
    cpp_prepend: str = ""


def write_field(key: str, value, depth: List[str]) -> FieldOutput:
    out = FieldOutput()

    def literal_node(typestr: str, default_value: str):
        out.hpp_inline = f"  {typestr} {member(key)};\n"
        out.cpp_inline = f'  {member(key)}(node["{key}"].IsDefined()?node["{key}"].as<{typestr}>():{default_value}),\n'

    def prepend_dict_node(dictvalue: dict):
        out.hpp_prepend = f"namespace {namespace(key)} {{\n"
        hpp_prepend_current = "struct dict {\n" + "  dict(const YAML::Node &node);\n"
        cpp_prepend_current = (
            "yamlgenpp::"
            + "::".join(map(namespace, depth + [key]))
            + "::dict"
            + "::dict(const YAML::Node &node):\n"
        )
        cpp_body_current = ""
        for sub_key, sub_value in dictvalue.items():
            sub_out = write_field(str(sub_key), sub_value, depth + [key])
            out.hpp_prepend += sub_out.hpp_prepend
            out.cpp_prepend += sub_out.cpp_prepend
            hpp_prepend_current += sub_out.hpp_inline
            cpp_prepend_current += sub_out.cpp_inline
            cpp_body_current += sub_out.cpp_body
        hpp_prepend_current += "};\n" + "}\n"
        cpp_prepend_current = cpp_prepend_current.rstrip().rstrip(",").rstrip(":")
        cpp_prepend_current += "{\n" + cpp_body_current + "}\n"
        out.hpp_prepend += hpp_prepend_current
        out.cpp_prepend += cpp_prepend_current

    if isinstance(value, str):
        literal_node("std::string", '""')
    elif isinstance(value, bool):
        literal_node("bool", "false")
    elif isinstance(value, int):
        literal_node("int", "0")
    elif isinstance(value, float):
        literal_node("double", "0")
    elif isinstance(value, list):
        has_dict = False
        dict_merged = {}
        has_str = False
        has_float = False
        has_bool = False
        for v in value:
            if isinstance(v, str):
                has_str = True
            elif isinstance(v, bool):
                has_bool = True
            elif isinstance(v, float) or isinstance(v, int):
                has_float = True
            elif isinstance(v, list):
                print(
                    f"Error parsing key '{'.'.join(depth + [key])}': list of list is not supported yet"
                )
                sys.exit(1)
            elif isinstance(v, dict):
                has_dict = True
                for sub_key, sub_value in v.items():
                    dict_merged[sub_key] = sub_value
        if has_dict:
            prepend_dict_node(dict_merged)
        if not value:
            print(f"Warning: key '{'.'.join(depth + [key])}' is empty list")
        elif int(has_str) + int(has_float) + int(has_bool) + int(has_dict) == 1:
            if has_dict:
                out.hpp_inline = (
                    f"  std::vector<{namespace(key)}::dict> {member(key)};\n"
                )
                out.cpp_body = (
                    f'    if(node["{key}"].IsDefined()) '
                    + f'for(const auto &value: node["{key}"]) '
                    + f"{member(key)}.emplace_back(value);\n"
                )
            elif has_str:
                out.hpp_inline = f"  std::vector<std::string> {member(key)};\n"
                out.cpp_body = (
                    f'    if(node["{key}"].IsDefined()) '
                    + f'for(const auto &value: node["{key}"]) '
                    + f"{member(key)}.emplace_back(value.as<std::string>());\n"
                )
            elif has_float:
                out.hpp_inline = f"  std::vector<double> {member(key)};\n"
                out.cpp_body = (
                    f'    if(node["{key}"].IsDefined()) '
                    + f'for(const auto &value: node["{key}"]) '
                    + f"{member(key)}.emplace_back(value.as<double>());\n"
                )
            elif has_bool:
                out.hpp_inline = f"  std::vector<bool> {member(key)};\n"
                out.cpp_body = (
                    f'    if(node["{key}"].IsDefined()) '
                    + f'for(const auto &value: node["{key}"]) '
                    + f"{member(key)}.emplace_back(value.as<bool>());\n"
                )
        else:
            print(
                f"Error parsing key '{'.'.join(depth + [key])}': list of mixed value is not supported yet (TODO)"
            )
            sys.exit(1)
    elif isinstance(value, dict):
        out.hpp_inline = f"  {namespace(key)}::dict {member(key)};\n"
        out.cpp_inline = (
            f'  {member(key)}(node["{key}"].IsDefined()?node["{key}"]:YAML::Node()),\n'
        )
        prepend_dict_node(value)
    else:
        print(
            f"Error parsing key '{'.'.join(depth + [key])}': unsupported type '{type(value)}'"
        )
        sys.exit(1)

    return out
